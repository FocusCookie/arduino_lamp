
#define WHITE_LED    0xFF000000
#define DIMWHITE_LED    0x80000000

#define BLACK     0x00000000
#define NAVY      0x00000080
#define DARKBLUE    0x0000008B
#define MEDIUMBLUE    0x000000CD
#define BLUE      0x000000FF
#define DARKGREEN   0x00006400
#define GREEN     0x00008000
#define TEAL      0x00008080
#define DARKCYAN    0x00008B8B
#define DEEPSKYBLUE   0x0000BFFF
#define DARKTURQUOISE   0x0000CED1
#define MEDIUMSPRINGGREEN 0x0000FA9A
#define LIME      0x0000FF00
#define SPRINGGREEN   0x0000FF7F
#define AQUA      0x0000FFFF
#define CYAN      0x0000FFFF
#define MIDNIGHTBLUE    0x00191970
#define DODGERBLUE    0x001E90FF
#define LIGHTSEAGREEN   0x0020B2AA
#define FORESTGREEN   0x00228B22
#define SEAGREEN    0x002E8B57
#define DARKSLATEGRAY   0x002F4F4F
#define LIMEGREEN   0x0032CD32
#define MEDIUMSEAGREEN    0x003CB371
#define TURQUOISE   0x0040E0D0
#define ROYALBLUE   0x004169E1
#define STEELBLUE   0x004682B4
#define DARKSLATEBLUE   0x00483D8B
#define MEDIUMTURQUOISE   0x0048D1CC
#define INDIGO      0x004B0082
#define DARKOLIVEGREEN    0x00556B2F
#define CADETBLUE   0x005F9EA0
#define CORNFLOWERBLUE    0x006495ED
#define MEDIUMAQUAMARINE  0x0066CDAA
#define DIMGRAY     0x00696969
#define SLATEBLUE   0x006A5ACD
#define OLIVEDRAB   0x006B8E23
#define SLATEGRAY   0x00708090
#define LIGHTSLATEGRAY    0x00778899
#define MEDIUMSLATEBLUE   0x007B68EE
#define LAWNGREEN   0x007CFC00
#define CHARTREUSE    0x007FFF00
#define AQUAMARINE    0x007FFFD4
#define MAROON      0x00800000
#define PURPLE      0x00800080
#define OLIVE     0x00808000
#define GRAY      0x00808080
#define SKYBLUE     0x0087CEEB
#define LIGHTSKYBLUE    0x0087CEFA
#define BLUEVIOLET    0x008A2BE2
#define DARKRED     0x008B0000
#define DARKMAGENTA   0x008B008B
#define SADDLEBROWN   0x008B4513
#define DARKSEAGREEN    0x008FBC8F
#define LIGHTGREEN    0x0090EE90
#define MEDIUMPURPLE    0x009370DB
#define DARKVIOLET    0x009400D3
#define PALEGREEN   0x0098FB98
#define DARKORCHID    0x009932CC
#define YELLOWGREEN   0x009ACD32
#define SIENNA      0x00A0522D
#define BROWN     0x00A52A2A
#define DARKGRAY    0x00A9A9A9
#define LIGHTBLUE   0x00ADD8E6
#define GREENYELLOW   0x00ADFF2F
#define PALETURQUOISE         0x00AFEEEE
#define LIGHTSTEELBLUE    0x00B0C4DE
#define POWDERBLUE    0x00B0E0E6
#define FIREBRICK   0x00B22222
#define DARKGOLDENROD   0x00B8860B
#define MEDIUMORCHID    0x00BA55D3
#define ROSYBROWN   0x00BC8F8F
#define DARKKHAKI   0x00BDB76B
#define SILVER      0x00C0C0C0
#define MEDIUMVIOLETRED         0x00C71585
#define INDIANRED     0x00CD5C5C
#define PERU      0x00CD853F
#define CHOCOLATE   0x00D2691E
#define TAN     0x00D2B48C
#define LIGHTGRAY   0x00D3D3D3
#define THISTLE     0x00D8BFD8
#define ORCHID      0x00DA70D6
#define GOLDENROD   0x00DAA520
#define PALEVIOLETRED   0x00DB7093
#define CRIMSON     0x00DC143C
#define GAINSBORO   0x00DCDCDC
#define PLUM      0x00DDA0DD
#define BURLYWOOD   0x00DEB887
#define LIGHTCYAN   0x00E0FFFF
#define LAVENDER    0x00E6E6FA
#define DARKSALMON    0x00E9967A
#define VIOLET      0x00EE82EE
#define PALEGOLDENROD   0x00EEE8AA
#define LIGHTCORAL    0x00F08080
#define KHAKI     0x00F0E68C
#define ALICEBLUE   0x00F0F8FF
#define HONEYDEW    0x00F0FFF0
#define AZURE     0x00F0FFFF
#define SANDYBROWN    0x00F4A460
#define WHEAT     0x00F5DEB3
#define BEIGE     0x00F5F5DC
#define WHITESMOKE    0x00F5F5F5
#define MINTCREAM   0x00F5FFFA
#define GHOSTWHITE    0x00F8F8FF
#define SALMON      0x00FA8072
#define ANTIQUEWHITE    0x00FAEBD7
#define LINEN     0x00FAF0E6
#define LIGHTGOLDENRODYELLOW  0x00FAFAD2
#define OLDLACE     0x00FDF5E6
#define RED     0x00FF0000
#define FUCHSIA     0x00FF00FF
#define MAGENTA     0x00FF00FF
#define DEEPPINK    0x00FF1493
#define ORANGERED   0x00FF4500
#define TOMATO      0x00FF6347
#define HOTPINK     0x00FF69B4
#define CORAL     0x00FF7F50
#define DARKORANGE    0x00FF8C00
#define LIGHTSALMON   0x00FFA07A
#define ORANGE      0x00FFA500
#define LIGHTPINK   0x00FFB6C1
#define PINK      0x00FFC0CB
#define GOLD      0x00FFD700
#define PEACHPUFF   0x00FFDAB9
#define NAVAJOWHITE   0x00FFDEAD
#define MOCCASIN    0x00FFE4B5
#define BISQUE      0x00FFE4C4
#define MISTYROSE   0x00FFE4E1
#define BLANCHEDALMOND    0x00FFEBCD
#define PAPAYAWHIP    0x00FFEFD5
#define LAVENDERBLUSH   0x00FFF0F5
#define SEASHELL    0x00FFF5EE
#define CORNSILK    0x00FFF8DC
#define LEMONCHIFFON    0x00FFFACD
#define FLORALWHITE   0x00FFFAF0
#define SNOW      0x00FFFAFA
#define YELLOW      0x00FFFF00
#define LIGHTYELLOW   0x00FFFFE0
#define IVORY     0x00FFFFF0
#define WHITE     0x00FFFFFF



#include <ButtonEvents.h>


// ADAFRUIT
#include <Adafruit_NeoPixel.h>
#ifdef __AVR__
#include <avr/power.h>
#endif

// Which pin on the Arduino is connected to the NeoPixels?
#define NEO_PIN    6  // NeoPixel DATA
// What type of NeoPixel strip is attached to the Arduino?
#define NEO_PTYPE  NEO_GRBW  // f.e. SK6812
//#define NEO_PTYPE NEO_GRB   // most NeoPixel products

// How many NeoPixels are attached to the Arduino?
#define NUMPIXELS  115

#define BRIGHTNESS  200 // set max brightness

#define IWAIT    2000
#define SWAIT   25
#define LWAIT   50
#define HWAIT   500

// Parameter 1 = number of pixels in strip
// Parameter 2 = Arduino pin number (most are valid)
// Parameter 3 = pixel type flags, add together as needed:
//   NEO_KHZ800  800 KHz bitstream (most NeoPixel products w/WS2812 LEDs)
//   NEO_KHZ400  400 KHz (classic 'v1' (not v2) FLORA pixels, WS2811 drivers)
//   NEO_GRB     Pixels are wired for GRB bitstream (most NeoPixel products)
//   NEO_RGB     Pixels are wired for RGB bitstream (v1 FLORA pixels, not v2)
//   NEO_GRBW    Pixels are wired for GRBW bitstream (f.e. SK6812)
Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUMPIXELS, NEO_PIN, NEO_PTYPE + NEO_KHZ800);

// IMPORTANT: To reduce NeoPixel burnout risk, add 1000 uF capacitor across
// pixel power leads, add 300 - 500 Ohm resistor on first pixel's data input
// and minimize distance between Arduino and first pixel.  Avoid connecting
// on a live circuit...if you must, connect GND first.

// NOTE: RGBW LEDs draw up to 80mA with all colors + white at full brightness!
// That means that a 60-pixel strip can draw up to 60x 80 = 4800mA, so you
// should use a 5A power supply; for a 144-pixel strip its max 11520mA = 12A!

// COLOR VARS for NEO Pixels
uint32_t warmWhite = strip.Color(0, 0, 0, 255);
uint32_t coldWhite = strip.Color(0, 0, 255, 255);
uint32_t magenta = strip.Color(255, 153, 255);
uint32_t magentaWhite = strip.Color(255, 0, 255, 255);
uint32_t red = strip.Color(255, 0, 0, 0);
uint32_t green = strip.Color(0, 255, 0, 0);
uint32_t blue = strip.Color(0, 0, 255, 0);
uint32_t yellow = strip.Color(0, 255, 255, 0);
uint32_t orange = strip.Color(255, 153, 0, 0);
uint32_t colors[] = {warmWhite, coldWhite, magentaWhite, magenta, red, green, orange, blue, yellow};
int colorsCount = 8;
// Black / OFF
uint32_t black = strip.Color(0, 0, 0, 0);


// Initialization of the needed variables<br />
int Counter = 255;
boolean direction;

int pinClkLastValue;
int pinClkCurrentValue;

// Definition of the input-pins
int PinCLK = 2;
int PinDT = 4;


const byte buttonPin = 3;
#define LED_PIN 13 // Builtin LED 
int ledState = LOW;

// ButtonEvents Instance
ButtonEvents button;


// LED STRIPES
int startStripe_1 = 0;
int startStripe_2 = 24;
int startStripe_3 = 46;
int startStripe_4 = 70;
int startStripe_5 = 92;

int endStripe_1 = 21;
int endStripe_2 = 45;
int endStripe_3 = 67;
int endStripe_4 = 91;
int endStripe_5 = 113;

boolean stripeStates[] = {1, 1, 1, 1, 1};
byte variations = 0b11111;
int stripeStartPosition = 0;

int maxStripes = 5;

// Variables for the lamp
int maxHeight = 22;

int lampMode = 0;
int maxLampMode = 4;
boolean lampState = false;
int brightnessFactor = 5;
int maxCounter;
int minCounter;

int currentColor = 0;
int currentBrightness = BRIGHTNESS;
int currentHeight = 22;
int currentStripeVariation = 0;

bool rainbowMode = false;


void setup()
{
  // Internal LED
  pinMode(LED_PIN, OUTPUT); // Setup the LED
  digitalWrite(LED_PIN, ledState);

  // Serial
  //Serial.begin (9600);

  // ******************************************************* KY404 SETUP
  // Initialization of the input-pins...
  pinMode (PinCLK, INPUT);
  pinMode (PinDT, INPUT);
  // ...and activating of their pull up resistors
  digitalWrite(PinCLK, true);
  digitalWrite(PinDT, true);
  // Initial reading of the Pin_CLK
  pinClkLastValue = digitalRead(PinCLK);
  // Button on KY404
  pinMode(buttonPin, INPUT_PULLUP);
  // Attach buttonEvents with the button pin
  button.attach(buttonPin);

  // ADAFRUIT LEDs
#ifdef __AVR_ATtiny85__
  // This is for Trinket 5V 16MHz
  if (F_CPU == 16000000) clock_prescale_set(clock_div_1);
  // End of trinket special code
#endif

  strip.begin(); // This initializes the NeoPixel library.
  strip.setBrightness(BRIGHTNESS); // set brightness
  strip.show(); // Initialize all pixels to 'off'

#ifdef IWAIT
  delay(IWAIT);
#endif

}

// The program checks, which of the status pins have changed first, to calculate the rotational direction,<br />// after a change of the pin status was detected.
// You will get this information if you compare the pin status of the current run with the pin status of the run before.<br />// After detecting the rotational direction, the steps from the start position will be counted and outputted.<br />// Pushing the button of the rotary encoder will reset the current position.




void loop()
{



  // Reading of the current status
  pinClkCurrentValue = digitalRead(PinCLK);

  // Check for a Change
  if (pinClkCurrentValue != pinClkLastValue)
  {

    if (digitalRead(PinDT) != pinClkCurrentValue)
    {
      // Pin_CLK has changed first
      direction = true;
      counterCheck(Counter, direction);

//      Serial.print("Current brightness: ");
//      Serial.println(currentBrightness);
//      Serial.println("------------------------------");
//
//      Serial.print("Current color: ");
//      Serial.println(currentColor);
//      Serial.println("------------------------------");
//
//      Serial.print("Current height: ");
//      Serial.println(currentHeight);
//      Serial.println("------------------------------");
//
//      Serial.print("maxCount: ");
//      Serial.println(maxCounter);
//      Serial.println("------------------------------");
//
//      Serial.print("currentStripeVariation: ");
//      Serial.println(currentStripeVariation);
//      Serial.println("------------------------------");



      lampControl();

    }

    else
    { // Else PinDT changed first
      direction = false;
      counterCheck(Counter, direction);

//      Serial.print("Current brightness: ");
//      Serial.println(currentBrightness);
//      Serial.println("------------------------------");
//
//      Serial.print("Current color: ");
//      Serial.println(currentColor);
//      Serial.println("------------------------------");
//
//      Serial.print("Current height: ");
//      Serial.println(currentHeight);
//      Serial.println("------------------------------");
//
//      Serial.print("maxCount: ");
//      Serial.println(maxCounter);
//      Serial.println("------------------------------");
//
//      Serial.print("currentStripeVariation: ");
//      Serial.println(currentStripeVariation);
//      Serial.println("------------------------------");


      lampControl();


    }
//    Serial.println("Rotational direction: ");
//
//    if (direction)
//    {
//      Serial.println ("Clockwise");
//    }
//    else
//    {
//      Serial.println("Counterclockwise");
//      Serial.print("Adresse zum Ausschalten");
//      Serial.println(startStripe_1 + currentHeight - 1);
//    }




  }





  // KY404 BUTTON
  button.update();

  if (button.tapped() == true) {
    ledState = !ledState; // Toggle LED state
    digitalWrite(LED_PIN, ledState); // Apply new LED state
    lampMode++;
    if (lampMode > maxLampMode) {
      lampMode = 1;
    }
    lampControl();
//    Serial.print("lampMode: ");
//    Serial.println(lampMode);
//    Serial.println("------------------------------");
//
//    Serial.print("Current position: ");
//    Serial.println(Counter);
//    Serial.println("------------------------------");
  }

  if (button.doubleTapped() == true) {
//    Serial.println("DOUBLE-TAP event detected");
//    Serial.println("RAINBOW MODE!!!");
    rainbowMode = !rainbowMode;
    if(rainbowMode){
       rainbow(LWAIT);
    }
  }

  if (button.held() == true) {
//  Serial.println("HOLD event detected");
    // switch off the lamp
    lampMode = 0;
    lampControl();
  }
}



// Fill the dots one after the other with a color
void colorWipe(uint32_t c, uint16_t wait) {
  for (uint16_t i = 0; i < currentHeight; i++) {
    // Stripe 1
    if (stripeStates[0]) {
      strip.setPixelColor(i + startStripe_1, c);
    } else {
      strip.setPixelColor(i + startStripe_1, black);
    }


    // Stripe 2
    if (stripeStates[1]) {
      strip.setPixelColor(endStripe_2 - i, c);
    } else {
      strip.setPixelColor(endStripe_2 - i, black);
    }

    // Stripe 3
    if (stripeStates[2]) {
      strip.setPixelColor(i + startStripe_3, c);
    } else {
      strip.setPixelColor(i + startStripe_3, black);
    }

    // Stripe 4
    if (stripeStates[3]) {
      strip.setPixelColor(endStripe_4 - i, c);
    } else {
      strip.setPixelColor(endStripe_4 - i, black);
    }

    // Stripe 5
    if (stripeStates[4]) {
      strip.setPixelColor(i + startStripe_5, c);
    } else {
      strip.setPixelColor(i + startStripe_5, black);
    }

    strip.show();
    delay(wait);
  }
}
// Fade off with reducing brightness
void fadeOff(uint16_t wait) {
  byte brightness;
  while ((brightness = strip.getBrightness()) > 0) {
    strip.setBrightness(--brightness);
    strip.show(); // This sends the updated pixel brightness to the hardware.
    delay(wait); // Delay for a period of time (in milliseconds).
  }
}

// led Stripe Height
void stripeHeight(uint16_t wait) {

  // direction = clockwise turn add height


  if (direction) {
    // SWITCH ON
    // Stripe 1
    if (stripeStates[0]) {
      strip.setPixelColor(startStripe_1 + currentHeight - 1, colors[currentColor]);
    }

    // Stripe 2
    if (stripeStates[1]) {
      strip.setPixelColor(endStripe_2 - currentHeight + 1, colors[currentColor]);
    }

    // Stripe 3
    if (stripeStates[2]) {
      strip.setPixelColor(startStripe_3 + currentHeight - 1, colors[currentColor]);
    }

    // Stripe 4
    if (stripeStates[3]) {
      strip.setPixelColor(endStripe_4 - currentHeight + 1, colors[currentColor]);
    }

    // Stripe 5
    if (stripeStates[4]) {
      strip.setPixelColor(startStripe_5 + currentHeight - 1, colors[currentColor]);
    }



    strip.show();
    delay(wait);
  }

  if (!direction) {
    // SWITCH OFF
    // Stripe 1
    if (stripeStates[0]) {
      strip.setPixelColor(startStripe_1 + currentHeight, black);
    }

    // Stripe 2
    if (stripeStates[1]) {
      strip.setPixelColor(endStripe_2 - currentHeight, black);
    }

    // Stripe 3
    if (stripeStates[2]) {
      strip.setPixelColor(startStripe_3 + currentHeight, black);
    }

    // Stripe 4
    if (stripeStates[3]) {
      strip.setPixelColor(endStripe_4 - currentHeight, black);
    }

    // Stripe 5
    if (stripeStates[4]) {
      strip.setPixelColor(startStripe_5 + currentHeight, black);
    }


    strip.show();
    delay(wait);
  }

}



void counterCheck(int32_t count, boolean clockwise) {
  switch (lampMode) {
    case 1: // Brightness
      // Max and min counter value
      maxCounter = BRIGHTNESS;

      if (clockwise) {
        currentBrightness += brightnessFactor;
      } else {
        currentBrightness -= brightnessFactor;
      }

      if (currentBrightness > maxCounter) {
        currentBrightness = maxCounter;
      }
      if (currentBrightness < brightnessFactor + 1) {
        currentBrightness = brightnessFactor;
      }
      break;
    case 2: // color
      // Max and min counter value
      maxCounter = colorsCount;
      minCounter = 0;

      if (clockwise) {
        currentColor++;
      } else {
        currentColor--;
      }

      if (currentColor > maxCounter) {
        currentColor = maxCounter;
      }
      if (currentColor < minCounter) {
        currentColor = minCounter;
      }
      break;
    case 3: // height
      // Max and min counter value
      maxCounter = maxHeight;
      minCounter = 1;


      if (clockwise) {
        currentHeight++;
      } else {
        currentHeight--;
      }

      if (currentHeight > maxCounter) {
        currentHeight = maxCounter;
      }
      if (currentHeight < minCounter) {
        currentHeight = minCounter;
      }
      break;
    case 4: // StripeAmount
      // Max and min counter value
      maxCounter = 15;
      minCounter = 0;


      if (clockwise) {
        currentStripeVariation++;
      } else {
        currentStripeVariation--;
      }

      if (currentStripeVariation > maxCounter) {
        currentStripeVariation = maxCounter;
      }
      if (currentStripeVariation < minCounter) {
        currentStripeVariation = minCounter;
      }
      break;
  }
}

void lampControl() {
  switch (lampMode) {
    case 0:
      fadeOff(SWAIT);
      strip.clear(); // turn all pixels off
      strip.setBrightness(currentBrightness); // restore max brightness value
      lampState = false;
      break;
    case 1:
      if (!lampState) {
        colorWipe(colors[currentColor], LWAIT);
        lampState = true;
      }
      strip.setBrightness(currentBrightness);
      strip.show(); // This sends the updated pixel brightness to the hardware.
      delay(SWAIT); // Delay for a period of time (in milliseconds).
      break;
    case 2:
      colorWipe(colors[currentColor], 10);
      break;
    case 3:
      stripeHeight(SWAIT);
      break;
    case 4:
      setStripeVariation(currentStripeVariation);
      colorWipe(colors[currentColor], 10);
      break;
  }
}

void setStripeVariation(uint16_t count) {
  switch (currentStripeVariation) {
    case 0:
      variations = 0b11111;
      break;
    case 1:
      variations = 0b10000;
      break;
    case 2:
      variations = 0b01000;
      break;
    case 3:
      variations = 0b00100;
      break;
    case 4:
      variations = 0b00010;
      break;
    case 5:
      variations = 0b00001;
      break;
    case 6:
      variations = 0b11000;
      break;
    case 7:
      variations = 0b01100;
      break;
    case 8:
      variations = 0b00110;
      break;
    case 9:
      variations = 0b00011;
      break;
    case 10:
      variations = 0b11100;
      break;
    case 11:
      variations = 0b01110;
      break;
    case 12:
      variations = 0b00111;
      break;
    case 13:
      variations = 0b10001;
      break;
    case 14:
      variations = 0b11011;
      break;
    case 15:
      variations = 0b01010;
      break;
  }

  stripeStates[0] = bitRead(variations, 4);
  stripeStates[1] = bitRead(variations, 3);
  stripeStates[2] = bitRead(variations, 2);
  stripeStates[3] = bitRead(variations, 1);
  stripeStates[4] = bitRead(variations, 0);

//  Serial.println("Stripe State");
//  for (uint16_t i = 0; i < 5; i++) {
//    Serial.print(i + 1);
//    Serial.print(" ---- Value ");
//    Serial.println(stripeStates[i]);
//  }
}

// Fill the dots one after the other with a color backward
void colorWipeReverse(uint32_t c, uint16_t wait) {
  for (uint16_t i = strip.numPixels(); i > 0; i--) {
    strip.setPixelColor(i - 1, c);
    strip.show();
    delay(wait);
  }
}

void rainbow(uint16_t wait) {
  uint16_t i, j;

  for (j = 0; j < 256; j++) {
    for (i = 0; i < strip.numPixels(); i++) {
      strip.setPixelColor(i, Wheel((i + j) & 255));
    }
    strip.show();
    delay(wait);
  }
}

// Slightly different, this makes the rainbow equally distributed throughout
void rainbowCycle(uint16_t wait) {
  uint16_t i, j;

  for (j = 0; j < 256 * 5; j++) { // 5 cycles of all colors on wheel
    for (i = 0; i < strip.numPixels(); i++) {
      strip.setPixelColor(i, Wheel(((i * 256 / strip.numPixels()) + j) & 255));
    }
    strip.show();
    delay(wait);
  }
}

//Theatre-style crawling lights.
void theaterChase(uint32_t c, uint16_t wait) {
  for (int j = 0; j < 10; j++) { //do 10 cycles of chasing
    for (int q = 0; q < 3; q++) {
      for (int i = 0; i < strip.numPixels(); i = i + 3) {
        strip.setPixelColor(i + q, c);  //turn every third pixel on
      }
      strip.show();

      delay(wait);

      for (int i = 0; i < strip.numPixels(); i = i + 3) {
        strip.setPixelColor(i + q, 0);      //turn every third pixel off
      }
    }
  }
}


// Input a value 0 to 255 to get a color value.
// The colours are a transition r - g - b - back to r.
uint32_t Wheel(byte WheelPos) {
  WheelPos = 255 - WheelPos;
  if (WheelPos < 85) {
    return strip.Color(255 - WheelPos * 3, 0, WheelPos * 3);
  } else if (WheelPos < 170) {
    WheelPos -= 85;
    return strip.Color(0, WheelPos * 3, 255 - WheelPos * 3);
  } else {
    WheelPos -= 170;
    return strip.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
  }
}
